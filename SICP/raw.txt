2023. 7. 30. 오후 10:28, 신종우 : 안녕하세요! 내일 출근을 앞두고 있는 예비 개발자 신종우입니다. 평소에 익히고 싶었던 책이 있었는데, 이번에 숙원을 이룰 기회인 것 같아서 참여하게 되었습니다. 잘 부탁드립니다!!

2023. 7. 31. 오후 9:56, 신종우 : # 자바스크립트로 배우는 SICP 1일차

## 전반적인 내용
지금은 폐강되었지만 SICP는 MIT의 신입생에게 프로그래밍을 가르쳐주는 과목이었다. 다른 언어에 비해 잘 쓰이지 않는 LISP을 선택하게 된 배경은 간단한 문법에 있다. 특정 언어의 문법에 한정되는 지식은 최대한 덜어내고 프로그래밍 그 자체에만 집중하기 위함이다. (자바스크립트는 "C의 옷을 입은 LISP"으로 불리는 만큼, LISP의 특징을 상당부분 수용하고 있다.)
이 책은 크게 1, 2, 3장과 4, 5장으로 구분 할 수 있는데, 전자는 코드의 구조와 추상화, 후자는 코드를 실행하는 기계(인터프리터, 컴파일러)에 대한 내용을 다루고 있다. 책 전반에 걸쳐서 전산한 기초 지식을 코드에 적용하는 방법을 익히게 되며, 이를 통해 컴퓨터를 대하는 올바른 멘탈 모델을 정립하고 올바른 추상화를 익히는 것이 주 목적이다.

## 독서 전략
이 책의 핵심은, 연습 문제를 모두 풀어보는 것이라고 한다. 
물론 모든 문제를 고민해서 풀어내는 것이 가장 좋겠지만, 9주 만에 업무와 병행하기에는 시간과 에너지가 충분하지 않을 수도 있다.
그러므로 연습문제는 솔루션을 참고하거나 지나치게 어려운 문제는 넘겨가며, 일단 본문을 끝까지 읽어내는 것에 집중하겠다.

## 다짐
함수형 프로그래밍에 관심을 갖게되면서, SICP를 알게되었다. 워낙 강력하게 추천하는 글이 많아서 호기심이 생겼는데, 꾸준히 읽기는 어려웠다.
책너두를 통해 이번에는 끝까지 읽을 수 있으면 좋겠다. 그리고 LISP 프로그래밍과 PL 지식도 얻어갈 수 있으면 좋겠다.



2023. 8. 1. 오후 10:30, 신종우 : # SICP 2일차

## 1.1.1 표현식

1. 원시 표현식: 가장 단순한 개체 (숫자, 문자, boolean 등…)
2. 조합 수단: 단순한 요소로 복합적인 요소를 만듦
3. 추상화 수단: 복합적인 요소에 이름을 붙여 하나의 단위로 다룸
크게 데이터와 함수로 구분할 수 있고, 둘 모두 값으로써 다루어질 수 있다.

## 1.1.2 이름 붙이기와 환경

계산적 객체에 이름을 붙이고, 값을 바인딩한다.
표현식 계산(평가)을 통해 값을 알아내려면, 어느 객체에 어떤 값이 바인딩 되어있는지 기록할 메모리 공간이 필요
그러한 메모리 공간을 환경(environment)라고 지칭함

## 1.1.3 연산자 조합의 평가

- 표현식 조합은 트리 꼴로 나타낼 수 있으며, 표현식 평가는 이 트리를 접는 것(tree accumulation)
- 임의의 노드에서 구조를 떼어낼 수 있는데, 이 자료 구조도 트리. 그렇기 때문에 표현식 평가는 재귀적으로 이루어 질 수 있다.
- 표현식 내에서 이름이 뜻하는 바는, 변수를 둘러싼 환경에 의해서 정해짐

## 1.1.4 복합 함수

- 함수 정의를 통해 데이터를 계산하는 과정을 추상화 할 수 있다.
- 정의된 함수는 다른 함수의 추상화에 사용할 수 있다.

## 1.1.5 함수 적용의 치환 모델

  함수 적용의 치환 모델(평가 전략)은 두 가지

  1. applicative-order evaluation
    - 대부분의 범용 프로그래밍 언어에서 택하는 평가 전략
    - 인자를 표현식으로 치환하기 전에, 해당 표현식의 평가를 완료한다.
    - eager evaluation이라고도 부름.

  2. normal-order evaluation

    - 인자를 표현식으로 먼저 치환하고, 값이 필요해질 때 표현식을 평가한다.
    - 대표적으로 haskell
    - lazy evaluation이라고도 부름.


2023. 8. 2. 오후 9:40, 신종우 : # SICP 3일차

## 1.1.6 조건부 표현식과 술어

- 조건부 표현식 (conditional expression)
  - 조건에 따라서 연산하는 방법을 다르게 함 (책에서 든 예시는 절댓값 구하기)
  - 절차지향 언어에서는 조건문(if statement, switch statement)으로 구현
  - LISP처럼 표현식을 지향하는 언어에서는 조건부 표현식
  - 자바스크립트에서 조건부 표현식은 삼항연산자로 표현할 수 있음
  - LISP에서는 `cond` 표현식으로, 조건이 두개 이상인 조건부 표현식을 구현할 수 있지만, 자바스크립트는 아직까지 switch expression이 없기 때문에, 삼항연산자를 체이닝하여 구현한다.

- 술어 (predicate)
  - 값을 인자로 받아, boolean으로 평가되는 순수 함수

## 1.1.7 예제: 뉴턴 방법으로 제곱근 구하기

- 제곱근을 구하는 함수
- 2의 제곱근이 1.414… 인 것은 선언적인 지식
- 기계(컴퓨터)가 제곱근을 구하는 과정은 절차적으로 기술되어야 함
- 적절한 값을 구하기 위해 근사치를 제안하고, 개선(improve)해가는 과정을 기술 (뉴턴법)
- 허용 범위 이내에 들어올 때까지 재귀적으로 프로시저 실행

## 1.1.8 블랙박스 추상으로서의 함수

- `sqrt` 함수를 모듈로써 바라봤을때, 사용된 부품들(`sqrt-iter`, `abs`, `good-enough` …)가 불필요하게 외부에 노출되어있다.
- 디미터 원칙(외부에 최소의 인터페이스만 노출)에 맞지 않음
- 다른 모듈과 이름이 충돌할 여지가 있음
- `sqrt` 함수 내부에 `sqrt-iter`, `abs`, `good-enough` 함수를 정의하여, 외부로 노출되는 인터페이스를 최소화하여 모듈화 할 수 있다.
- 함수내부에 함수를 정의하는 구조를 블록구조라고 한다. (ALGOL 60에서 물려받은 특징)
- lexical scoping (또는 static scoping)

2023. 8. 3. 오후 10:18, 신종우 : # SICP 4일차

## 1.2.1 선형 재귀와 반복

- 프로시저란 컴퓨터 프로세스가 어떻게 나아가는지를 밝힌 것 (= 프로시저가 만들어 내는 프로세스)
- 본문에서 든 예시는 계승(factorial)을 구하는 함수
- 선형 재귀 프로시저는 재귀 바닥을 호출할 때 까지 표현식을 늘어놓고, 역순으로 표현식을 평가한다.
- 때문에, 재귀 호출만큼의 기억 공간(메모리)이 필요하다.
- 반면, 선형 반복 프로시저는 연산되는 과정에서 변하는 상태를 별도의 변수에 기록하고 있기 때문에 기억 공간(메모리)가 재귀 호출 횟수만큼 필요하지는 않다.
- 꼬리재귀의 형태로 선형 반복을 표현할 수 있으며, 컴파일러(또는 인터프리터)가 반복 프로시저로 최적화한다.

## 1.2.2 트리 재귀

- 재귀 호출은 트리 꼴로 일어날 수 있다. (본문에서 든 예시는 피보나치 수열)
- 트리의 차수가 커질 수록 지수 비례로 재귀 호출의 수가 많아진다.
- 예시로 든 피보나치 수열의 n번째 항을 구하는 프로시저는 꼬리 재귀 프로시저로 최적화 할 수 있다.(반복 프로시저)
- 이 경우, 지수 비례가 아닌 선형 비례 만큼의 수로 재귀 호출한다.
- 재귀 프로시저의 코드는 반복 프로시저에 비해 성능은 매우 떨어지지만, 보다 수학적 정의에 가까운 형태다.

## 1.2.3 증가 차수

- 프로세스가 컴퓨팅 자원을 얼마나 소모하는지 비교하기 위해, 증가 차수로 비교한다.
- 연산의 수(시간 복잡도)와 기억공간(공간 복잡도)로 구분할 수 있다.

## 1.2.4 거듭제곱

- 거듭제곱을 구하기 위해 거듭제곱의 승수만큼 곱할 수도 있지만, 절반의 승수를 제곱하는 방법으로 최적화 할 수 있다. (O(N) -> O(NlogN))

## 1.2.5 최대공약수

- 유클리드 호제법
  - 최대공약수를 구하는 알고리즘
  - 가장 오래된 알고리즘
  - O(logN) 시간복잡도를 가진다.(라메의 정리)

2023. 8. 4. 오후 9:41, 신종우 : # SICP 5일차

## 1.2.6 예제: 소수 판정

- 자연수 n이 소수인지 판별하려면, 1 부터 sqrt(n) 사이의 수로 전부 나누어 떨어지는 지 확인한다.
- 가장 직관적이고, naive한 알고리즘
- O(sqrt(N))만큼의 시간복잡도를 가진다.
- 페르마 검사를 이용하면 O(logN)에 소수인지 판별할 수 있다. (상당한 차이)
- 하지만 항상 올바른 답을 내지는 않는다.
  - 카마이클 수는 합성수 이지만 페르마 테스트를 통과
  - probabilistic algorithm
- 응용사례: RSA 알고리즘. RSA 알고리즘에는 상당히 큰 소수가 사용된다. (RSA-2048인 경우에 2048 bit)

## 1.3.1 함수를 받는 함수

- 프로시저(함수)의 인자로 프로시저를 받는다.
- 본문에서 든 예시는 시그마 표현(sigma notation)
- 조금 더 실용적인 예시
  - map, filter, reduce 함수의 인자.
  - 자바스크립트의 event handler function

## 1.3.2 람다 표현식을 이용한 함수 구축

- 함수의 인자로 함수를 넘기기만 할 때는 굳이 이름을 붙일 필요가 없음
- 이 경우, 람다 표현식을 사용해서 표현을 보다 간결하게 한다.
- 자바스크립트에서는 표현방법이 두가지. (함수 표현식, 화살표 함수)
- 익명 함수

2023. 8. 6. 오후 9:02, 신종우 : # SICP 6일차

## 1.3.3 일반적 방법으로서의 함수

- 이분법을 활용해 정해진 범위 내에서 답을 찾아낼 수 있다.(parametric search)
- 고정점(fixed point)
  - f(x)와 x가 동일할 때 (또는 허용범위 내로 차이날 때), x를 fixed point라 함
  - 뉴턴법으로 제곱근을 구하는 것도, fixed point를 찾아내는 문제로 일반화 할 수 있음
  - 다만, 제곱근을 구하는 문제에서는 x가 fixed point로 근사하지 못하는 경우를 막기위해, average damping을 적용해야 함

## 1.3.4 함수를 돌려주는 함수

- 프로시저(함수)는 다른 프로시저를 인자로 받아 표현력을 올릴 수 있다.
- 프로시저를 리턴하는 프로시저를 정의하면 표현력을 더 올릴 수 있다.(일반화 할 수 있다.)
- 본문에서 든 예시는 미분(함수 f를 받아 도함수를 리턴함)
- 일급
  - 권리와 특권
    - 변수의 값이 될 수 있다.
    - 프로시저 인자로 쓸 수 있다.
    - 프로시저의 결과로 만들어질 수 있다.
    - 데이터 구조 속에 집어넣을 수 있다.
  - 비용
    - 프로시저가 프로시저를 리턴하는 경우. 자유변수를 저장해야함 (closure)
    - 따라서, 별도의 기억장소가 필요
    - 자유변수에 대한, 메모리 관리가 필요함 (ex. garbage collection)


2023. 8. 7. 오후 10:08, 신종우 : # SICP 7일차

## 2.1.1 예제: 유리수 산술 연산

- 유리수(rational number)의 연산은 정수 연산과 다르다.
- 가령 덧셈을 하는 경우를 보자면, 분모를 통분하고 분자끼리 정수 덧셈을 하는 과정이 있다.
- cons 연산을 통해 분모와 분자를 하나의 자료구조로 엮을 수 있다.(constructor)
- car와 cdr연산으로는 묶여진 자료구조에서 필요한 데이터를 골라낼 수 있다.(selector)
- 예제에서는 cons로 두 정수를 묶어 유리수로 취급하고, 분모와 분자는 car, cdr로 골라낸다.

## 2.1.2 추상화 장벽

- 추상화가 올바르게 이루어졌다면, 내부 모듈의 구조가 어떤지 신경쓰지 않고 프로그램을 짤 수 있다.
- Single Responsibility Principle

## 2.1.3 데이터란 무엇인가?

- 복합 자료 구조만이 아니라, 그 자료 구조에 대한 연산도 같이 정의해야 데이터라고 할 수 있음
- cons가 내놓는 값이 프로시저라고 볼 수도 있음 (이때, 이 프로시저는 closure)
- lua의 iterator구현
- 프로시저를 값으로 봄으로써 표현력이 올라감

## 2.1.4 심화 연습문제: 구간 산술

- 두 저항을 병렬연결했을 때, 합성 저항값을 내는 프로시저를 만듦
- 두 저항은 오차범위내에서 오차가 있고, 따라서 합성 저항 값 역시 오차를 가짐
- 두 저항의 범위를 받아서, 합성 저항의 범위를 내는 프로시저를 만들어야 함


2023. 8. 8. 오전 7:53, 신종우 : # SICP 8일차

## 2.2.1 순차열의 표현

- 리스트: cons 연산으로 만들 수 있는 자료구조
- 리스트의 node 하나는 cons cell 이라고도 부름
- 리스트의 끝은 nil
- `list`연산: 리스트를 만들기 위한 syntactic sugar
- `null?`프로시저: 빈 리스트인지 확인하는 predicate
- 리스트 연산
  - 리스트와 프로시저를 인자로 받아, 새로운 리스트를 내놓는다.
  - cdring down & cons up
  - cdring down: 리스트 순회
  - cons up: 새로운 리스트를 엮어냄
- dotted-tail notation
  - LISP에서 가변 길이 인자를 처리하기 위한 문법
  - 자바스크립트에서는 rest
- map 연산
  - 리스트와 프로시저를 인자로 받아. 리스트의 모든 원소에 프로시저가 적용된 새 리스트를 내놓는다.
  - LISP의 map은 다른 언어의 map보다 더 넓은 범위에서 쓰인다.

## 2.2.2 위계적 구조

- 트리: 일반화 리스트 (리스트는 트리의 특수한 경우)
- `pair?`프로시저: pair(cons cell)인지 아닌지를 판별함
- 리스트 연산을 재귀적으로 수행하면 트리에도 같은 프로시저를 적용할 수 있다.(일반화)
  - 트리는 일반화 된 리스트이기 때문


2023. 8. 9. 오후 1:57, 신종우 : # SICP 9일차

## 2.2.3 합의된 인터페이스로서의 순차열

- `sum-odd-squares`프로시저와 `even-fibs`프로시저는 얼개(속성 또는 목적)이 크게 다르지만, 신호를 처리하는(자료구조를 다루는) 관점에서는 구조가 유사하다.
- map: 각 원소에 프로시저를 적용한다.
- filter: 원소에 predicate을 적용해 참인 원소만 골라낸다.
- reduce: 모든원소를 하나로 접는다.(accumulate 또는 fold)
- reduce로 map과 filter를 구현할 수 있다.
- map, filter, reduce에 higher-order 프로시저를 인자로 넘김으로써, 관심사를 분리할 수 있다.
- C++ STL의 구조도 같은 맥락이다. 어떤 자료구조이더라도(벡터, 리스트, 맵) 자료구조를 순회할 수 있는 인터페이스(iterator)를 제공한다면 같은 구조로 다룰 수 있다.

2023. 8. 10. 오후 1:50, 신종우 : # SICP 10일차

## 2.2.4 예제: 그림 언어

- 닫힘 성질 (closure)
  - 프로그래밍 언어의 closure와는 전혀다른 개념
  - 어떤 집합의 원소를 연산한 결과가 같은 집합에 속해있는 성질
  - 예시: 자연수의 덧셈
- 페인터를 엮는 프로시저 below나 beside는 페인터 프로시저를 인자로 받아 페인터 프로시저를 내놓는다.(닫힌 대수구조)
- 그렇기 때문에 페인터들을 엮어 하나의 페인터로 모듈화 할 수 있고, 이렇게 모듈화된 페인터는 더 복잡한 페인터의 부품으로 쓰일 수 있다.
- 다층 설계(stratified design)


2023. 8. 11. 오후 10:39, 신종우 : # SICP 11일차

## 2.3.1 문자열

- LISP은 homoiconic language
- 데이터(리스트)와 코드(s-expression)의 생김새가 동일하다.
- 리스트를 s-expression으로써 평가하지 않기 위해 quote 연산을 사용한다.
- 누군가에게 "이름을 말하라"고하면, 본인의 이름을 말하겠지만(평가) "'이름'을 말하라"고 하면, "이름"이라는 단어를 말할 것이다.(문자열로 취급)
- `eq?`프로시저 두 문자열 비교해서 같은지 판별한다.

## 2.3.2 예제: 기호 미분

- 다항식을 미분하는 프로시저를 만든다.
- 다항식의 연산자를 문자열 기호로 다룸으로써 다항식을 평가하지 않고 미분된 식을 내놓을 수 있다.('+, '*)
- 다항식을 트리구조로 다룬다.
  - LISP과 동일한 표기법으로 prefix 꼴로 다항식을 표현한다.(연산자 우선 순위를 고려할 필요가 없음.)
  - 덧셈식으로 연결(cons)되었거나. 곱셈식으로 연결됨.
- car와 cdr로 다항식의 계수와 변수를 골라낼 수 있다.

- 감상: 메타프로그래밍을 하는 듯한 느낌이 있는데, 확실히 LISP의 문법이 훨씬 유연하다.


2023. 8. 13. 오후 12:02, 신종우 : # SICP 12일차

## 2.3.3 예제: 집합의 표현

- 집합을 구현한다.(다른 언어의 set 자료구조)
- 구현해야하는 연산(프로시저)
  1. `union-set`: 두 집합을 인자로 받아, 합집합을 내놓는다.
  2. `intersection-set`: 두 집합을 인자로 받아, 교집합을 내놓는다.
  3. `element-of-set?`: 원소와 집합을 인자로 받아, 집합에 속하는 원소인지 판별한다.
  4. `adjoin-set`: 원소와 집합을 집합을 인자로 받아, 원소가 추가된 새 집합을 내놓는다.

- unordered list 기반 집합

  - `element-of-set?`: O(n)
  - `union-set`: O(n*m)
  - `intersection-set`: O(n*m)
  - `adjoin-set`: O(n)
  - `element-of-set?`프로시저를 나머지 세 프로시저가 쓰고 있으므로, 프로시저들의 시간 복잡도는 `adjoin-set`의 시간 복잡도에 의존한다.

- ordered list 기반 집합

  - `element-of-set?`: O(n)
    - 시간 복잡도 표기는 동일하지만 리스트를 끝까지 확인할 필요가 없기 때문에 lower bound가 내려간다.
  - `union-set`: O(n+m)
    - 집합의 최솟값, 최댓값을 비교하는 문제로 환원된다.
  - `intersection-set`: O(n+m)
    - 모든 리스트를 비교할 필요가 없으므로, 부분집합에서 교집합을 구하는 문제로 환원된다.
  - `adjoin-set`: O(n)

- binary tree 기반 집합

  - `element-of-set?`: O(logn)
  - `union-set`: O(n+m)
  - `intersection-set`: O(n+m)
  - `adjoin-set`: O(logn)
  - 트리가 한 쪽으로 치우치면 ordered list와 동일하다.
    - 이를 보강하기 위해 balanced tree 자료구조를 사용할 수 있다.
    - C++ STL의 ordered-set


2023. 8. 15. 오전 1:03, 신종우 : # SICP 13일차

## 2.3.4 허프먼 부호화 트리

- 허프만 트리
  - 유일복호가능이면서 "순간 부호"
  - 자주 쓰이는 문자의 크기를 압축할 수록 효과가 좋다.
- `weight` 프로시저
  - generic procedure
  - 잎이냐 나무냐에 따라 다른 동작

## 2.4.1 복소수의 여러 표현

- 복소수의 두가지 표현: 직각 좌표계, 극좌표계
- 상황에 따라 두 표현 중 하나를 골라서 쓰는 것이 유리함. (덧셈은 직각 좌표계가 유리하고, 곱셈은 극좌표가 유리함.)
- contructor
  - `make-from-real-imag`
  - `make-from-mag-ang`
- selector
  - `real-part`
  - `imag-part`
  - `magnitude`
  - `angle`
- 직각 좌표계와 극좌표계 표기법의 사칙연산은 각각 내부 구현이 다르다.
- 하지만 쓰는 입장에서는 어느 표기법이건 동일한 결과를 내어야 하므로, 일반화 된 인터페이스를 제공할 필요가 있다.


2023. 8. 16. 오전 2:32, 신종우 : # SICP 14일차

## 2.4.2 태그된 데이터

- 복소수의 표기법에 따라 사칙연산하는 방법이 달라진다.
- 직각 좌표계 복소수와 극좌표계 복소수를 구별할 필요가 있다. (type을 정할 필요)
- `'rectangular` 태그 또는 `'polar` 태그를 cons로 붙여서 구분한다.  
- 타입이 구별되어 있으므로, 어떤 복소수 프로시저를 적용할 지 정할 수 있다.
- 추상화 계층 사이를 넘으며, 태그(타입)을 붙였다 뗐다 하는 기법은 자주 쓰이는 기법

## 2.4.3 데이터 지향적 프로그래밍과 가산성

- 데이터 타입에 따라 적절한 프로시저를 불러쓰는 방법(dispatching on type)
- 직전에 설계한 복소수 연산 프로시저의 약점
  1. 새로운 연산 또는 타입을 추가할 때, 복소수의 모든 표현 방식을 알아야 한다.
  2. 프로시저의 이름이 충돌하지 않아야 한다.
- 프로그램의 확장을 방해하는 약점들 (OCP 위배)
- 모듈 방식에 맞게 시스템을 설계하는 방법이 필요 (데이터 중심 프로그래밍)
- 연산(프로시저)와 타입을 두 축으로 하는 2차원 테이블
- 데이터 중심 프로그래밍이란, 이러한 테이블을 바탕으로 프로시저 및 자료구조를 구현하는 것

2023. 8. 16. 오후 9:22, 신종우 : # SICP 15일차

## 2.5.1 일반적 산술 연산

- 일반화된 산술연산 (제네릭, 오버로딩)
- 가령 덧셈을 하는 경우, 기본 수에 대해서는 기본 + 연산, 유리수에 대해서는 `add-rat` 프로시저, 복소수에 대해서는 `add-complex`를 적용하는 프로시저를 생각해 볼 수 있다.
- `apply-generic`프로시저
  - 가로 축이 데이터 타입, 세로 축이 프로시저인 테이블을 상상했을 때
  - `apply-generic` 프로시저는 세로 축에서 먼저 프로시저의 이름(태그)으로 행을 고르고
  - 그 행에서, 데이터 타입의 이름(태그)으로 실제 프로시저를 골라낸다. (추상화 수준이 더 낮고, 구체적인 프로시저)
- 복소수는 추상화 깊이가 한 단계 더 있어서(직각좌표계, 극좌표계), 이러한 테이블 참조가 한 번 더 발생한다.

## 2.5.2 형식이 서로 다른 데이터 객체들의 결합

- 지금까지 설계한 일반화된 프로시저로는 서로 다른 타입 간 연산을 구현하는 것이 어렵다. (데이터 타입의 수^프로시저의 인자 수 만큼, 경우의 수가 존재)
- 일반화된 프로시저라고 보기 어려움
- 어떤 타입의 데이터를 다른 타입의 데이터로 바꿈으로써 일반화된 프로시저 구조를 유지할 수 있다.
- 가령, 정수 2 는 유리수 2/1 로 취급될 수 있고, 복소수 2+0i 로 취급될 수도 있다.
- 타입 변환(type coercion)
- 데이터의 타입을 변경하는 프로시저를 별도로 만들고, 실제 연산이 이루어지는 프로시저는 간단한 구조를 유지한다.
- 타입 간 변환이 불가능한 경우도 있음. 타입 간 위계(hierarchy)가 있기 때문
- 타입의 탑 구조
- 상위 타입으로 변환하는 `raise` 프로시저: 타입 변환 `raise`프로시저로 일반화 됨
- 또한 가장 단순한 구조로 내리는 것도 일반화 할 수 있다.(`lower`프로시저)
- 하지만, 예제처럼 데이터의 탑 구조가 명확한 구조는 흔치않다. 사각형의 위계 구조가 그 예시


2023. 8. 17. 오후 10:39, 신종우 : # SICP 16일차

## 2.5.3 예제: 기호 대수

- 기호 대수식의 연산을 다루는 예제.
- 모든 기호 대수식의 연산을 다루는 것은 상당이 복잡한 작업이므로 문제를 간소화 한다.
- 다항식의 덧셈과 곱셈
- 추상화된 데이터(abstracted data)와 일반화된 연산(generic operation)을 활용함 
- 다항식을 엮어쓰려면, 다항식의 변수가 같아야한다는 제약조건.
- 다항식의 타입은 `polynomial`
- 덧셈은 마디단위로 처리하고, 재귀적으로 나머지 항들을 더한다.
- 프로시저
  - `the-empty-termlist`: 빈 마디 리스트를 만듦 (nil을 리턴하는 프로시저)
  - `adjoin-term`: 리스트에 새 마디를 붙임 (cons)
  - `first-term`: 최고차항 마디를 뽑아냄 (car)
  - `rest-terms`: 나머지 마디 리스트 (cdr)
  - `empty-termlist?` 
  - `make-term`: 계수와 차수를 인자로 받아 마디를 만들어냄
  - `order`: 마디에서 차수를 뽑아냄
  - `coeff`: 마디에서 계수를 뽑아냄
- 추상화된 데이터 타입 `polynomial`에 해당하는 프로시저 연산 `add-terms`와 `mul-terms`를 일반화된 연산으로 떠넘길 수 있다.
- 기호 대수식도 같은 대수 구조로 취급 할 수 있으므로, 일반화된 연산(generic operation)을 적용할 수 있다.

2023년 8월 18일 금요일

2023. 8. 19. 오전 1:01, 신종우 : # SICP 17일차

## 3.1.1 지역 상태 변수

- 이번 장 부터, 현실 세계와 더 가까운 프로그램을 작성한다.
- 상태를 가지는 물체를 구현한다.
- 예제는 계좌의 입/출금
- `withdraw` 프로시저는 계좌에서 임의의 금액을 인출하는 프로시저
- 앞서 만들었던 프로시저는 같은 인자에 대해서, 항상 같은 값을 내놓았지만, `withdraw` 프로시저는 그렇지 않다.(순수함수가 아님)
- 값 할당(assign)을 위해 `set!` 이라는 특별한 형태(special form)가 쓰인다. (다른 언어의 = 대입 연산자와 동일함)
- `begin` special form: `(begin <exp1> <exp2> <exp3>)`인 경우 `<exp3>`로 평가된다.
- `set!`으로 할당을 허용하면서, 맞바꿈 계산(substitution model)이 유효하지 않아짐
- `set!` 이 들어간 s-expression은 expression보다 statement에 가깝다
- `withdraw`와 함께 `deposit`도 구현할 수 있는데, 책에서는 메세지 패싱 방식으로 구현함

## 3.1.2 배정 도입의 이득

- `rand-update`: 무작위 수의 수열이 있다고 했을 때, 이 수열에 속하는 어떤 무작위 수를 인자로 받아, 다음 차례의 무작위 수를 내놓는다.(순수 함수)
- `rand`: 인자를 받지 않고, 호출 할 때 마다 다음 수열을 내놓는다.
- 예제의 몬테 카를로 시뮬레이션에서 `rand`프로시저의 유용함이 드러남.
- `rand`프로시저를 사용하면 `cesaro-test`를 분리해 낼 수 있었지만, `rand-update`프로시저로 같은 기능을 하는 프로시저를 작성하면 분리해 낼 수 없다.
- 관심사의 분리가 되지 않았고, 덜 직관적인 코드


2023. 8. 20. 오후 12:35, 신종우 : # SICP 18일차

## 3.1.3 배정 도입의 비용

- `set!` 덕분에 상태가 변하는 물체를 나타낼 수 있다.
- 자바스크립트에서는 `const` 대신 `let`을 사용한 효과
- 하지만 객체의 상태가 변하기 때문에, 같은 입력에 대해서 항상 같은 결과를 기대할 수 없는 문제가 있다.
- 또한, substitutional 계산이 불가능 하다.
- 할당은 문(statement)를 통해 이루어지므로, 어떤 값으로 평가되기 어렵다.
- referential transparency를 잃음
- 상태를 허용하지 않고, substitutional하게 계산하는(평가하는) 방식으로 프로그램을 짜는 것이 함수형 프로그래밍
- 반대로 상태를 바꾸어가며 프로그램을 짜는 것은 명령형 프로그래밍
- 더 이상, substitutional 계산이 유효하지 않으므로 새로운 멘탈 모델이 필요함. (함수형 프로그래밍과 명령형 프로그래밍을 모두 아우르는)

## 3.2.1 평가 규칙들

- 환경 계산법
- 코드가 평가(또는 실행)될 때, 그 어휘가 지칭하는 값을 환경에서 찾아낸다.
- 어휘가 정의된 환경에서 찾아내지 못하면 상위 환경에서 찾아내고, 거기서도 찾아내지 못하면, 최상위 환경까지 순차적으로 탐색한다.
- lexical scoping(static scoping)
- 어휘와 환경이 binding되는 것은, 코드가 작성되는 시점에 정해진다.
- 반대로 코드가 작성되는 시점에 정해지지 않을 수도 있는데, 이는 dynamic scoping


2023. 8. 22. 오전 12:23, 신종우 : # SICP 19일차

## 3.2.2 간단한 함수 적용의 예

- 1.1.5절의 `sum-of-squares` 프로시저를 새로운 멘탈모델(환경 계산법)으로 해석한다.
- 프로시저를 호출(또는 평가)할 때마다, 고유한 환경이 생성된다.
- 생성된 환경에는 변수에 대해 어떤 값이 바인딩 되어있는지, 표시되어있다.(테이블)
- 자신과 가장 가까운 환경에서부터, 바깥쪽으로 탐색해나가며 변수에 바인딩 된 값을 찾아낸다.
- 프로시저(함수) 역시 일급 객체이므로, 테이블에 그 값(참조 또는 포인터)이 바인딩되어 있다.

## 3.2.3 지역 상태 저장소로서의 프레임

- 앞서 살펴본 `make-withdraw` 프로시저를 환경 계산법으로 해석한다.
- `(define W1 (make-withdraw 100))`식과 `(define W2 (make-withdraw 100))`식으로 생겨난 `W1`과 `W2`는 계좌를 공유하지 않는다. (각각 고유한 환경에 변수가 바인딩 되어 있으므로)

## 3.2.4 내부 선언

- 1.1.8절의 `sqrt` 프로시저를 환경 계산법으로 해석한다.
- 블록 구조를 통해 갇힌 프로시저(local procedure)를 정의했었다.
  - 프로시저 밖에 있는 다른 변수 이름과 섞일 일이 없다.
  - 안쪽 프로시저는 바깥 프로시저의 변수를 자유변수(free variable)처럼 쓸 수 있다.
- 이 두 가지 장점이 closure의 특징 (SICP에서는 이런 의미로 closure라는 어휘를 쓰지는 않는다. 전혀 다른 의미로 쓰이는데, 닫힌 대수 구조를 지칭한다)

2023. 8. 23. 오전 7:27, 신종우 : # SICP 20일차

## 3.3.1 변경 가능 목록 구조

- assignment를 도입하면서, 자료구조를 조작하는 프로시저가 추가됨.
- `cons`, `car`, `cdr`로 불변 자료 구조를 조작할 수 있다.
- `set-car!`와 `set-cdr!` 도입
- 프로시저 이름 그대로 pair의 요소를 덮어쓸 수 있다.
- `append!`프로시저는 새 리스트를 내놓는 것이 아니라, 원본 리스트에 이어붙인다.
- 불변 자료 구조에서는 데이터를 공유하는 것이 문제가 없었지만,
- 값을 변경시킬 수 있게 되면서, 공유된 자료 구조 사이에 얘기치 않은 변경이 발생할 수 있다.

## 3.3.2 대기열의 표현

- FIFO 자료구조
- 리스트에 단순히 원소를 넣고, 빼는 것만 하면 됨
- 원소를 빼는 것은 O(1)에 일어날 수 있지만, 추가하는 것은 리스트의 끝을 찾아야하므로 O(n)이 걸린다.
- 리스트의 끝을 보게 함으로써, O(1)에 추가하는 것을 달성할 수 있다.


2023. 8. 23. 오전 9:17, 신종우 : # SICP 21일차

## 3.3.3 테이블의 표현

- 레코드(pair의 참조)가 원소인 리스트
- 이 때 리스트는, 테이블의 backbone이라고 함
- `assoc`프로시저: 테이블에서 키를 통해 레코드를 조회함
- `lookup`프로시저: 테이블에서 키에 맞는 값을 찾아냄. `assoc` 프로시저를 사용한다.
- `insert!`프로시저: 테이블에서 새 레코드를 추가함
- 테이블 구조의 일관성을 위해 맨 앞 pair의 first에는 `*table*`이라는 가짜 레코드를 넣는다.
- 이차원 표를 구현하면: 앞서 패키지로 구현했던, `put`, `get`프로시저를 구현할 수 있다.

## 3.3.4 디지털 회로 시뮬레이터

- 논리 소자를 조합하는 계층 설계
- 신호의 타이밍을 다루는 것이 까다롭다
- non-deterministic 프로그래밍
- `get-signal`: wire를 인자로 받아, 신호를 잡아냄 (subscription)
- `set-signal!`: wire와 값을 인자로 받아, 값을 신호로 보냄 (subscription)
- `add-action!`: 줄에 걸린 신호가 바뀔때 처리할 프로시저를 지정함 (continuation passing style)
- `after-delay`: 시간과 프로시저를 인자로 받아, 특정 시간 뒤에 프로시저를 실행


2023. 8. 25. 오전 5:42, 신종우 : # SICP 22일차

## 3.3.4 디지털 회로 시뮬레이터

- 줄 만들기
  - 줄을 나타내는 물체의 상태변수
    - `signal-value`: 신호
    - `action-procedures`: 신호가 변할 때 돌아갈 함수의 모음
  - 상태를 가진 `dispatch` 프로시저: lexically 정의된 환경을 가지고 다닌다.
- 시간표
  - `after-delay` 만들기
  - `agenda` 자료구조 만들기
  - 필요한 프로시저
    `make-agenda`: 새 시간표를 만든다
    `empty-agenda?`: 시간표가 비어 있는지 살펴본다.
    `first-agenda-item`: 시간표에서 처음 할 일을 꺼낸다.
    `remove-first-agenda-item!`: 시간표에서 처음 할 일을 지운다.
    `add-to-agenda!`: 정한 시간에 할 일을 시간표에 추가한다.
    `current-time`: 시뮬레이션 상 현재 시간을 확인한다.
  - `after-delay` 프로시저는 `add-to-agenda!` 프로시저를 실행해 새 원소를 테이블에 추가한다
  - `propagate` 프로시저로 시뮬레이션을 실행한다.
- 시뮬레이션 해보기
  - `probe` 프로시저
    - 탐침
    - 신호가 변했을 때, 신호의 값, 시간, 줄 이름을 출력한다.
    - `tap` 함수와 유사함
- 시간표 만들기
  - 시간표는 여러 time segment로 이루어져 있고, time segment는 시간을 나타내는 수와, 큐를 묶어서 만든다.
  - 같은 time segment에 할 일이 있다면 큐에 enqueue 한다.
  - 할 일이 없으면 time segment 삭제
  - 일감을 꺼낼 때마다, 현재 시간도 갱신

## 3.3.5 관계 알리기

- 등식에서 어떤 변수를 제외한 나머지 변수의 값을 알면, 그 변수의 값을 알아낼 수 있다. (관계를 가지고 있다.)
- 한 변수에 대해서만 값을 구하는 프로시저가 아니라, 등식의 모든 변수에 대해 값을 구하는 프로시저
- 예제는 섭씨-화씨 변환 계산
- 소자들을 연결해 그물망을 만든다
- 단자에 값을 흘려보내면 반대쪽 단자에서 값이 나온다.
- 이때 반대쪽 단자에 값을 흘려보내면, 에러 발생
- `forget-value`프로시저로 단자에 걸려있던 값을 지운다.
- 관계 시스템 만들기
  - 디지털 회로 시뮬레이터와 유사함
  - 필요한 프로시저
    - `has-value?`: 연결선에 값이 있는지 확인
    - `get-value`: 연결선에 있는 값을 읽음
    - `set-value!`: 연결선에 새 값을 덮어쓰려고 함
    - `forget-value!`: 연결선에 걸린 값을 지우려고 함
    - `connect`: 연결선을 단자에 끼움

2023. 8. 26. 오전 12:31, 신종우 : # SICP 23일차

## 3.3.5 관계 알리기

- 연결선 만들기
- 연결선을 나타내는 상태
  - `value`: 현재 연결선에 실려 있는 값
  - `informant`: 값을 보낸 소자
  - `constraints`: 연결선에 붙어있는 관계
- `set-value!` 프로시저를 통해 관계망에 값이 전파됨

## 3.4.1 동시적 시스템에서 시간의 본질

- 사건이 일어나는 차례
- producer consumer 문제
- 상태 변수 하나를 동시에 조작하는 것이 원인
- 임계영역의 필요성

## 3.4.2 동시성 제어 메커니즘

- 동시에 일어나는 사건의 순서는 섞일 수 있기 때문에, 순서를 따져봐야한다.
- 병행시스템을 설계하는 방법 중 하나가 serializer


2023. 8. 28. 오전 12:16, 신종우 : # SICP 24일차

## 3.4.2 동시성 제어 메커니즘

- 한 상태를 여러 프로시저가 동시에 바꾸려고 하는 경우
- 한 프로시저가 실행되는 동안, 다른 프로시저도 상태를 갱신하려고 한다.
- producer consumer 문제 외에도, 프로시저 실행의 원자성이 보장되지 않아서 생기는 문제가 있다.
- 이 경우, 프로시저를 줄세워서(serialize) 같은 상태를 갱신하는 프로시저가 동시에 실행되지 않도록 한다.
- 임계영역 확보
- 여러 자원을 쓰는 경우에는 그에 맞추서 임계영역을 조정할 필요가 있다.
- 예제에서는 프로시저 내부에 감추었던 serializer를 밖으로 꺼내어 쓰는 식
- serializer의 구현은 mutex로 할 수 있는데, 본문에서는 busy-waiting방식으로 구현하고 있다.(꼬리재귀인 점만 빼면 spin lock과 동일함)
- 임계영역에 의해 데드락이 생길 수 있다.
- 데드락을 피하기 위해 우선순위를 매기거나 하는 방법을 사용 할 수 있다.
- 데드락을 피하지 못하는 경우도 있다.

## 3.5 스트림

- 변수의 값을 덮어써가며, 상태를 추적하는 것은 복잡한 일
- 상태를 추적하는 대신 함수의 입/출력으로 문제를 다루면 간단해 질 수도 있다.
- 다른 입력을 받아 다른 결과를 내더라도, 함수 그 자체는 변하지 않기 때문
- 스트림 처리를 위해, delayed evaluation 기법을 도입할 것이다.

2023. 9. 4. 오후 8:50, 신종우 : # SICP 25일차

## 3.5.1 스트림과 (계산을) 미룬 리스트

- sequential 자료구조를 processing 하는 것은 iterative(또는 imperative)하는 것보다 자원의 낭비가 클 수 있다.
- 필요하지 않는 데이터를 처리하느라 자원을 낭비할 수 있기 때문
- 가령, 10000개의 소수중에 첫번째와 두번째만 필요한 경우에 모든 소수를 구하느라 자원을 낭비
- 이는 코드의 표현력과 성능이 trade-off 관계라고 볼 수도 있지만,
- 스트림을 통해 sequential 자료구조(리스트)를 processing 하는 것과 동일한 표현력으로, 성능도 챙길 수 있다.
- `delay` 프로시저로 계산을 미루고(thunkify), `force` 프로시저로 필요한 시점에 계산한다.
- 실제로 계산이 완료된 값을 취급하는 것이 아니라 필요한 시점에 계산하겠다는 약속을 프로시저의 인자로 주고받음
- 성능 향상을 위해 `memo-proc`도 적용(memoization)
- modern programming language에서는 제너레이터의 형태로 표현 가능

## 3.5.2 무한 스트림

- 스트림 자료구조를 활용해 무한한 에라토스테네스의 체를 구현한다.
- 리스트와 동일한 표현력
- 재귀적 정의 (핸더슨 그림 참고)


2023. 9. 5. 오후 10:40, 신종우 : # SICP 26일차

## 3.5.3 스트림 패러다임

- 스트림 기법으로 명령형 코드와 같은 동작을 더 나은 표현력을 가진 코드로 작성할 수 있다.
- 매 순간 변하는 상태변수 대신, 흐르는 신호를 처리하는 것으로 취급
- 1장에서 구현했던 `sqrt-iter`를 스트림 기법으로 모델링 할 수 있다.
- 1.3.1 절의 라이프니츠의 수열도 스트림 기법으로 모델링 할 수 있다.(원주율 구하기)
- sequence accelerator를 활용해 원주율에 더 빠르게 접근할 수 있다.
- 오일러 기법: 부호가 번갈아가며 바뀌는 수열의 부분합을 나타냄상
- 스트림의 스트림(태블로 구조)를 활용하면 더 가속시킬 수 있다.
- 2.2.3절의 `prime-sum-pairs`를 사용해서 모든 정수에 대한 스트림으로부터 조건을 만족하는 스트림을 만든다.
- 두 정수의 스트림을 `interleave`프로시저로 묶는다.


2023. 9. 6. 오후 10:23, 신종우 : # SICP 27일차

## 3.5.4 스트림과 셈미룸 계산법

- `int`(적분) 프로시저가 정의 될 수 있는 것은 `cons-stream` 내부에 있는 `delay`연산 때문
- `delay`연산을 꺼내써야하는 경우가 있을 수도 있음 (본문의 `solve` 프로시저)
- `dy` 매개변수가 정의되기전에 사용됨
- `dy`에 `delay` 연산을 적용하여 해결한다.
- `delay`와 `force`로 프로그램의 표현력을 끌어올릴 수 있다.
- 하지만 프로시저를 엮어낼 때, `delay`, `force` 규칙을 따라야 한다는 것을 인지해야한다.
- 4장에서 평가순서를 바꿀 것
- lazy evaluation과 mutability는 잘 맞지않는다

## 3.5.5 모듈로 바라본 함수와 물체

- 스트림을 사용하여 상태변수 없이, 상태가 있는 물체를 표현할 수 있다.
- 3.1.2 절의 몬테카를로 법에서는 순수 함수형 프로그래밍 대신, 상태를 허용하면서 표현력이 올라갔다.
- 이번 절에서는 스트림으로 동일한 프로그램을 표현
- 스트림 기법과 상태 변수를 두는 방법 모두 널리 쓰이지만, 어느 한 쪽도 완벽한 답은 아님
